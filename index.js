// Generated by CoffeeScript 1.4.0
(function() {
  var helpers, _,
    __slice = [].slice;

  _ = require('underscore');

  helpers = require('helpers');

  exports.decorate = function(decorator, f) {
    return function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return decorator.apply(this, [f].concat(args));
    };
  };

  exports.MakeThrottle = function(options) {
    if (options == null) {
      options = {};
    }
    options.lasttime = 1;
    options.wait = 100;
    options.queue = [];
    return function() {
      var args, diff, f, sink;
      f = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      console.log('my f is', f);
      sink = function() {
        args = options.queue.shift();
        f.apply(this, args);
        if (options.queue.length) {
          return setTimeout(sink, options.wait);
        } else {
          return options.lasttime = new Date().getTime();
        }
      };
      if (options.queue.length) {
        return options.queue.push(args);
      }
      if ((diff = new Date().getTime() - options.lasttime) > options.wait) {
        f.apply(this, args);
        return options.lasttime = new Date().getTime();
      } else {
        if (!options.queue.length) {
          setTimeout(sink, diff);
        }
        return options.queue.push(args);
      }
    };
  };

  exports.makeNoHammer = function(options) {
    var history;
    if (options == null) {
      options = {};
    }
    if (!options.waittime) {
      options.waittime = 1000;
    }
    history = {};
    return function() {
      var args, f;
      f = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (!history[args[0]]) {
        history[args[0]] = true;
        helpers.wait(options.waittime, function() {
          return delete history[args[0]];
        });
        return f.apply(this, args);
      }
    };
  };

  exports.makeDelayExec = function(options) {
    if (options == null) {
      options = {};
    }
    if (!options.waittime) {
      options.waittime = 1000;
    }
    return function() {
      var args, f,
        _this = this;
      f = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      helpers.wait(options.waittime, function() {
        return f.apply(_this, args);
      });
      return void 0;
    };
  };

}).call(this);
